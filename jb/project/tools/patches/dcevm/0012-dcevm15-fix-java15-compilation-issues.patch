From 2dd09ce40a545a4256f990346e5cebf23dbf0b56 Mon Sep 17 00:00:00 2001
From: Vladimir Dvorak <vladimir.dvorak@jetbrains.com>
Date: Fri, 12 Feb 2021 10:10:02 +0100
Subject: [PATCH 12/39] dcevm15 - fix java15 compilation issues

---
 .../share/classfile/classFileParser.hpp       |   8 +-
 .../share/classfile/classLoaderData.cpp       |   2 +-
 src/hotspot/share/classfile/dictionary.hpp    |   9 +-
 src/hotspot/share/classfile/javaClasses.cpp   |   5 -
 src/hotspot/share/classfile/javaClasses.hpp   |   3 +-
 src/hotspot/share/classfile/vmSymbols.hpp     |   1 -
 .../share/gc/g1/g1FullGCCompactTask.cpp       |   4 +-
 .../share/gc/g1/g1FullGCCompactionPoint.cpp   |   8 +-
 .../share/gc/g1/g1FullGCPrepareTask.cpp       |   4 +-
 src/hotspot/share/gc/shared/dcevmSharedGC.cpp |  14 +-
 src/hotspot/share/gc/shared/dcevmSharedGC.hpp |   2 +-
 src/hotspot/share/gc/shared/gcConfig.cpp      |   2 +-
 src/hotspot/share/gc/shared/space.cpp         |   4 +-
 src/hotspot/share/oops/instanceKlass.cpp      |  17 +-
 src/hotspot/share/oops/instanceKlass.hpp      |   1 +
 src/hotspot/share/oops/klass.cpp              |   8 +-
 src/hotspot/share/prims/jvm.cpp               |   2 +
 .../prims/jvmtiEnhancedRedefineClasses.cpp    | 176 +++++++++---------
 .../prims/jvmtiEnhancedRedefineClasses.hpp    |  18 +-
 src/hotspot/share/prims/jvmtiEnv.cpp          |  11 +-
 .../share/prims/jvmtiRedefineClasses.cpp      |   1 +
 src/hotspot/share/prims/methodHandles.hpp     |   3 +
 .../share/prims/resolvedMethodTable.cpp       | 139 ++++++++------
 src/hotspot/share/runtime/arguments.cpp       |   8 +-
 src/hotspot/share/runtime/mutexLocker.cpp     |   2 +-
 25 files changed, 255 insertions(+), 197 deletions(-)

diff --git a/src/hotspot/share/classfile/classFileParser.hpp b/src/hotspot/share/classfile/classFileParser.hpp
index 0f94bc2501a..52ad6faa443 100644
--- a/src/hotspot/share/classfile/classFileParser.hpp
+++ b/src/hotspot/share/classfile/classFileParser.hpp
@@ -145,9 +145,6 @@ class ClassFileParser {
   const intArray* _method_ordering;
   GrowableArray<Method*>* _all_mirandas;
 
-  // Enhanced class redefinition
-  const bool _pick_newest;
-
   enum { fixed_buffer_size = 128 };
   u_char _linenumbertable_buffer[fixed_buffer_size];
 
@@ -201,6 +198,9 @@ class ClassFileParser {
   bool _has_vanilla_constructor;
   int _max_bootstrap_specifier_index;  // detects BSS values
 
+  // (DCEVM) Enhanced class redefinition
+  const bool _pick_newest;
+
   void parse_stream(const ClassFileStream* const stream, TRAPS);
 
   void mangle_hidden_class_name(InstanceKlass* const ik);
@@ -563,7 +563,7 @@ class ClassFileParser {
   ClassLoaderData* loader_data() const { return _loader_data; }
   const Symbol* class_name() const { return _class_name; }
   const InstanceKlass* super_klass() const { return _super_klass; }
-  Array<Klass*>* local_interfaces() const { return _local_interfaces; }
+  Array<InstanceKlass*>* local_interfaces() const { return _local_interfaces; }
 
   ReferenceType reference_type() const { return _rt; }
   AccessFlags access_flags() const { return _access_flags; }
diff --git a/src/hotspot/share/classfile/classLoaderData.cpp b/src/hotspot/share/classfile/classLoaderData.cpp
index db50b3edee8..2a826ff50a7 100644
--- a/src/hotspot/share/classfile/classLoaderData.cpp
+++ b/src/hotspot/share/classfile/classLoaderData.cpp
@@ -603,7 +603,7 @@ void ClassLoaderData::exchange_holders(ClassLoaderData* cld) {
   oop holder_oop = _holder.peek();
   _holder.replace(cld->_holder.peek());
   cld->_holder.replace(holder_oop);
-  WeakHandle<vm_class_loader_data> exchange = _holder;
+  WeakHandle<vm_weak_data> exchange = _holder;
   _holder = cld->_holder;
   cld->_holder = exchange;
 }
diff --git a/src/hotspot/share/classfile/dictionary.hpp b/src/hotspot/share/classfile/dictionary.hpp
index 359da0f150c..bdfef5c8663 100644
--- a/src/hotspot/share/classfile/dictionary.hpp
+++ b/src/hotspot/share/classfile/dictionary.hpp
@@ -82,6 +82,11 @@ public:
   void print_on(outputStream* st) const;
   void verify();
 
+  // (DCEVM) Enhanced class redefinition
+  bool update_klass(unsigned int hash, Symbol* name, ClassLoaderData* loader_data, InstanceKlass* k, InstanceKlass* old_klass);
+
+  void rollback_redefinition();
+
  private:
   DictionaryEntry* new_entry(unsigned int hash, InstanceKlass* klass);
 
@@ -102,10 +107,6 @@ public:
   void add_protection_domain(int index, unsigned int hash,
                              InstanceKlass* klass,
                              Handle protection_domain);
-  // Enhanced class redefinition
-  bool update_klass(unsigned int hash, Symbol* name, ClassLoaderData* loader_data, InstanceKlass* k, InstanceKlass* old_klass);
-
-  void rollback_redefinition();
 
   // (DCEVM) return old class if redefining in AllowEnhancedClassRedefinition, otherwise return "k"
   static InstanceKlass* old_if_redefined(InstanceKlass* k) {
diff --git a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
index 73b1672440d..dc800debea4 100644
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -4109,11 +4109,6 @@ void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop
   resolved_method->obj_field_put(_vmholder_offset, holder);
 }
 
-void java_lang_invoke_ResolvedMethodName::set_vmholder_offset(oop resolved_method, Method* m) {
-  assert(is_instance(resolved_method), "wrong type");
-  resolved_method->obj_field_put(_vmholder_offset, m->method_holder()->java_mirror());
-}
-
 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle& m, TRAPS) {
   const Method* method = m();
 
diff --git a/src/hotspot/share/classfile/javaClasses.hpp b/src/hotspot/share/classfile/javaClasses.hpp
index 1c08c9761e4..32348c90ef9 100644
--- a/src/hotspot/share/classfile/javaClasses.hpp
+++ b/src/hotspot/share/classfile/javaClasses.hpp
@@ -295,7 +295,9 @@ class java_lang_Class : AllStatic {
   static void set_init_lock(oop java_class, oop init_lock);
   static void set_protection_domain(oop java_class, oop protection_domain);
   static void set_class_loader(oop java_class, oop class_loader);
+ public: // DCEVM
   static void set_component_mirror(oop java_class, oop comp_mirror);
+ private:
   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
                                        Handle classData, TRAPS);
   static void set_mirror_module_field(JavaThread* current, Klass* K, Handle mirror, Handle module);
@@ -1151,7 +1153,6 @@ class java_lang_invoke_ResolvedMethodName : AllStatic {
 
   static Method* vmtarget(oop resolved_method);
   static void set_vmtarget(oop resolved_method, Method* method);
-  static void set_vmholder_offset(oop resolved_method, Method* method);
 
   static void set_vmholder(oop resolved_method, oop holder);
 
diff --git a/src/hotspot/share/classfile/vmSymbols.hpp b/src/hotspot/share/classfile/vmSymbols.hpp
index 0ce4a2fe2b5..dad94005f5c 100644
--- a/src/hotspot/share/classfile/vmSymbols.hpp
+++ b/src/hotspot/share/classfile/vmSymbols.hpp
@@ -487,7 +487,6 @@
   template(static_offset_name,                        "staticOffset")                             \
   template(static_base_name,                          "staticBase")                               \
   template(field_offset_name,                         "fieldOffset")                              \
-  template(field_type_name,                           "fieldType")                                \
                                                                                                   \
    /* name symbols needed by intrinsics */                                                         \
                                                                                                   \
diff --git a/src/hotspot/share/gc/g1/g1FullGCCompactTask.cpp b/src/hotspot/share/gc/g1/g1FullGCCompactTask.cpp
index fbc6c7f0e3e..54edc9dffb5 100644
--- a/src/hotspot/share/gc/g1/g1FullGCCompactTask.cpp
+++ b/src/hotspot/share/gc/g1/g1FullGCCompactTask.cpp
@@ -158,14 +158,14 @@ void G1FullGCCompactTask::serial_compaction_dcevm() {
 
 size_t G1FullGCCompactTask::G1CompactRegionClosureDcevm::apply(oop obj) {
   size_t size = obj->size();
-  HeapWord* destination = (HeapWord*)obj->forwardee();
+  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());
   if (destination == NULL) {
     // Object not moving
     return size;
   }
 
   // copy object and reinit its mark
-  HeapWord* obj_addr = (HeapWord*) obj;
+  HeapWord* obj_addr = cast_from_oop<HeapWord*>(obj);
 
   if (!_rescue_oops_it->at_end() && **_rescue_oops_it == obj_addr) {
     ++(*_rescue_oops_it);
diff --git a/src/hotspot/share/gc/g1/g1FullGCCompactionPoint.cpp b/src/hotspot/share/gc/g1/g1FullGCCompactionPoint.cpp
index 14d4cd2e78a..71a46b88f9e 100644
--- a/src/hotspot/share/gc/g1/g1FullGCCompactionPoint.cpp
+++ b/src/hotspot/share/gc/g1/g1FullGCCompactionPoint.cpp
@@ -170,7 +170,7 @@ void G1FullGCCompactionPoint::forward_dcevm(oop object, size_t size, bool force_
   assert(_current_region != NULL, "Must have been initialized");
 
   // Store a forwarding pointer if the object should be moved.
-  if ((HeapWord*)object != _compaction_top || force_forward) {
+  if (cast_from_oop<HeapWord*>(object) != _compaction_top || force_forward) {
     object->forward_to(oop(_compaction_top));
   } else {
     if (object->forwardee() != NULL) {
@@ -184,11 +184,11 @@ void G1FullGCCompactionPoint::forward_dcevm(oop object, size_t size, bool force_
     } else {
       // Make sure object has the correct mark-word set or that it will be
       // fixed when restoring the preserved marks.
-      assert(object->mark_raw() == markOopDesc::prototype_for_object(object) || // Correct mark
-             object->mark_raw()->must_be_preserved(object) || // Will be restored by PreservedMarksSet
+      assert(object->mark_raw() == markWord::prototype_for_klass(object->klass()) || // Correct mark
+             object->mark_must_be_preserved() || // Will be restored by PreservedMarksSet
              (UseBiasedLocking && object->has_bias_pattern_raw()), // Will be restored by BiasedLocking
              "should have correct prototype obj: " PTR_FORMAT " mark: " PTR_FORMAT " prototype: " PTR_FORMAT,
-             p2i(object), p2i(object->mark_raw()), p2i(markOopDesc::prototype_for_object(object)));
+             p2i(object), object->mark_raw().value(), markWord::prototype_for_klass(object->klass()).value());
     }
     assert(object->forwardee() == NULL, "should be forwarded to NULL");
   }
diff --git a/src/hotspot/share/gc/g1/g1FullGCPrepareTask.cpp b/src/hotspot/share/gc/g1/g1FullGCPrepareTask.cpp
index eedf3b0f576..05f0444cc7a 100644
--- a/src/hotspot/share/gc/g1/g1FullGCPrepareTask.cpp
+++ b/src/hotspot/share/gc/g1/g1FullGCPrepareTask.cpp
@@ -298,7 +298,7 @@ size_t G1FullGCPrepareTask::G1PrepareCompactLiveClosureDcevm::apply(oop object)
   HeapWord* compact_top = _cp->forward_compact_top(forward_size);
 
   if (compact_top == NULL || must_rescue(object, oop(compact_top))) {
-    _cp->rescued_oops()->append((HeapWord*)object);
+    _cp->rescued_oops()->append(cast_from_oop<HeapWord*>(object));
   } else {
     _cp->forward_dcevm(object, forward_size, (size != forward_size));
   }
@@ -324,7 +324,7 @@ bool G1FullGCPrepareTask::G1PrepareCompactLiveClosureDcevm::must_rescue(oop old_
   int new_size = old_obj->size_given_klass(oop(old_obj)->klass()->new_version());
   int original_size = old_obj->size();
 
-  bool overlap = ((HeapWord*)old_obj + original_size < (HeapWord*)new_obj + new_size);
+  bool overlap = (cast_from_oop<HeapWord*>(old_obj) + original_size < cast_from_oop<HeapWord*>(new_obj) + new_size);
 
   return overlap;
 }
diff --git a/src/hotspot/share/gc/shared/dcevmSharedGC.cpp b/src/hotspot/share/gc/shared/dcevmSharedGC.cpp
index 803e645f843..3dee097f1d3 100644
--- a/src/hotspot/share/gc/shared/dcevmSharedGC.cpp
+++ b/src/hotspot/share/gc/shared/dcevmSharedGC.cpp
@@ -58,10 +58,10 @@ void DcevmSharedGC::copy_rescued_objects_back(GrowableArray<HeapWord*>* rescued_
           DcevmSharedGC::update_fields(rescued_obj, new_obj);
         } else {
           rescued_obj->set_klass(new_klass);
-          Copy::aligned_disjoint_words((HeapWord*)rescued_obj, (HeapWord*)new_obj, size);
+          Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(rescued_obj), cast_from_oop<HeapWord*>(new_obj), size);
         }
       } else {
-        Copy::aligned_disjoint_words((HeapWord*)rescued_obj, (HeapWord*)new_obj, size);
+        Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(rescued_obj), cast_from_oop<HeapWord*>(new_obj), size);
       }
 
       new_obj->init_mark_raw();
@@ -111,11 +111,11 @@ void DcevmSharedGC::update_fields(oop q, oop new_location) {
 
   // Save object somewhere, there is an overlap in fields
   if (new_klass_oop->is_copying_backwards()) {
-    if (((HeapWord *)q >= (HeapWord *)new_location && (HeapWord *)q < (HeapWord *)new_location + new_size) ||
-        ((HeapWord *)new_location >= (HeapWord *)q && (HeapWord *)new_location < (HeapWord *)q + size)) {
+    if ((cast_from_oop<HeapWord*>(q) >= cast_from_oop<HeapWord*>(new_location) && cast_from_oop<HeapWord*>(q) < cast_from_oop<HeapWord*>(new_location) + new_size) ||
+        (cast_from_oop<HeapWord*>(new_location) >= cast_from_oop<HeapWord*>(q) && cast_from_oop<HeapWord*>(new_location) < cast_from_oop<HeapWord*>(q) + size)) {
        tmp = NEW_RESOURCE_ARRAY(HeapWord, size);
        q = (oop) tmp;
-       Copy::aligned_disjoint_words((HeapWord*)tmp_obj, (HeapWord*)q, size);
+       Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(tmp_obj), cast_from_oop<HeapWord*>(q), size);
     }
   }
 
@@ -131,13 +131,13 @@ void DcevmSharedGC::update_fields(oop q, oop new_location) {
 
 void DcevmSharedGC::update_fields(oop new_location, oop tmp_obj, int *cur) {
   assert(cur != NULL, "just checking");
-  char* to = (char*)(HeapWord*)new_location;
+  char* to = (char*)cast_from_oop<HeapWord*>(new_location);
   while (*cur != 0) {
     int size = *cur;
     if (size > 0) {
       cur++;
       int offset = *cur;
-      HeapWord* from = (HeapWord*)(((char *)(HeapWord*)tmp_obj) + offset);
+      HeapWord* from = (HeapWord*)(((char *)cast_from_oop<HeapWord*>(tmp_obj)) + offset);
       if (size == HeapWordSize) {
         *((HeapWord*)to) = *from;
       } else if (size == HeapWordSize * 2) {
diff --git a/src/hotspot/share/gc/shared/dcevmSharedGC.hpp b/src/hotspot/share/gc/shared/dcevmSharedGC.hpp
index e2ef0171fb2..a4e27e00280 100644
--- a/src/hotspot/share/gc/shared/dcevmSharedGC.hpp
+++ b/src/hotspot/share/gc/shared/dcevmSharedGC.hpp
@@ -29,7 +29,7 @@
 #include "gc/shared/genOopClosures.hpp"
 #include "gc/shared/taskqueue.hpp"
 #include "memory/iterator.hpp"
-#include "oops/markOop.hpp"
+#include "oops/markWord.hpp"
 #include "oops/oop.hpp"
 #include "runtime/timer.hpp"
 #include "utilities/growableArray.hpp"
diff --git a/src/hotspot/share/gc/shared/gcConfig.cpp b/src/hotspot/share/gc/shared/gcConfig.cpp
index 891a75ace08..26a2b67b8e9 100644
--- a/src/hotspot/share/gc/shared/gcConfig.cpp
+++ b/src/hotspot/share/gc/shared/gcConfig.cpp
@@ -98,7 +98,7 @@ void GCConfig::fail_if_non_included_gc_is_selected() {
 void GCConfig::select_gc_ergonomically() {
   if (AllowEnhancedClassRedefinition && !UseG1GC) {
     // Enhanced class redefinition only supports serial GC at the moment
-    FLAG_SET_ERGO(bool, UseSerialGC, true);
+    FLAG_SET_ERGO(UseSerialGC, true);
   } else if (os::is_server_class_machine()) {
 #if INCLUDE_G1GC
     FLAG_SET_ERGO_IF_DEFAULT(UseG1GC, true);
diff --git a/src/hotspot/share/gc/shared/space.cpp b/src/hotspot/share/gc/shared/space.cpp
index bec9c91d40a..29a81348d2d 100644
--- a/src/hotspot/share/gc/shared/space.cpp
+++ b/src/hotspot/share/gc/shared/space.cpp
@@ -436,7 +436,7 @@ int CompactibleSpace::space_index(oop obj) {
     index++;
   }
 
-  tty->print_cr("could not compute space_index for %08xh", (HeapWord*)obj);
+  tty->print_cr("could not compute space_index for %08xh", cast_from_oop<HeapWord*>(obj));
   index = 0;
 
   Generation* gen = heap->old_gen();
@@ -481,7 +481,7 @@ bool CompactibleSpace::must_rescue(oop old_obj, oop new_obj) {
   bool new_in_tenured = tenured_gen->is_in_reserved(new_obj);
   if (old_in_tenured == new_in_tenured) {
     // Rescue if object may overlap with a higher memory address.
-    bool overlap = ((HeapWord*)old_obj + original_size < (HeapWord*)new_obj + new_size);
+    bool overlap = (cast_from_oop<HeapWord*>(old_obj) + original_size < cast_from_oop<HeapWord*>(new_obj) + new_size);
     if (old_in_tenured) {
       // Old and new address are in same space, so just compare the address.
       // Must rescue if object moves towards the top of the space.
diff --git a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
index 994f6bf266f..ef0091fe288 100644
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -1281,7 +1281,7 @@ void InstanceKlass::init_implementor() {
 // (DCEVM) - init_implementor() for dcevm
 void InstanceKlass::init_implementor_from_redefine() {
   assert(is_interface(), "not interface");
-  Klass** addr = adr_implementor();
+  Klass* volatile* addr = adr_implementor();
   assert(addr != NULL, "null addr");
   if (addr != NULL) {
     *addr = NULL;
@@ -1633,6 +1633,21 @@ void InstanceKlass::methods_do(void f(Method* method)) {
   }
 }
 
+void InstanceKlass::methods_do(void f(Method* method, TRAPS), TRAPS) {
+  // Methods aren't stable until they are loaded.  This can be read outside
+  // a lock through the ClassLoaderData for profiling
+  if (!is_loaded()) {
+    return;
+  }
+
+  int len = methods()->length();
+  for (int index = 0; index < len; index++) {
+    Method* m = methods()->at(index);
+    assert(m->is_method(), "must be method");
+    f(m, CHECK);
+  }
+}
+
 //  (DCEVM) Update information contains mapping of fields from old class to the new class.
 //  Info is stored on HEAP, you need to call clear_update_information to free the space.
 void InstanceKlass::store_update_information(GrowableArray<int> &values) {
diff --git a/src/hotspot/share/oops/instanceKlass.hpp b/src/hotspot/share/oops/instanceKlass.hpp
index 36587031fec..317a006a4ec 100644
--- a/src/hotspot/share/oops/instanceKlass.hpp
+++ b/src/hotspot/share/oops/instanceKlass.hpp
@@ -1017,6 +1017,7 @@ public:
   void clear_update_information();
 
   void methods_do(void f(Method* method));
+  void methods_do(void f(Method* method, TRAPS), TRAPS);
   void array_klasses_do(void f(Klass* k));
   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
 
diff --git a/src/hotspot/share/oops/klass.cpp b/src/hotspot/share/oops/klass.cpp
index 17c1b27af7d..55ea76a8558 100644
--- a/src/hotspot/share/oops/klass.cpp
+++ b/src/hotspot/share/oops/klass.cpp
@@ -203,13 +203,13 @@ void* Klass::operator new(size_t size, ClassLoaderData* loader_data, size_t word
 // which doesn't zero out the memory before calling the constructor.
 Klass::Klass(KlassID id) : _id(id),
                            _prototype_header(markWord::prototype()),
-                           _shared_class_path_index(-1),
-                           _new_version(NULL),
                            _old_version(NULL),
+                           _new_version(NULL),
+                           _redefinition_flags(Klass::NoRedefinition),
                            _is_redefining(false),
+                           _update_information(NULL),
                            _is_copying_backwards(false),
-                           _redefinition_flags(Klass::NoRedefinition),
-                           _update_information(NULL) {
+                           _shared_class_path_index(-1) {
   CDS_ONLY(_shared_class_flags = 0;)
   CDS_JAVA_HEAP_ONLY(_archived_mirror_index = -1;)
   _primary_supers[0] = this;
diff --git a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
index a7fe090ba01..2966343c835 100644
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -958,6 +958,7 @@ static jclass jvm_lookup_define_class(jclass lookup, const char *name,
     ik = SystemDictionary::resolve_from_stream(&st, class_name,
                                                class_loader,
                                                cl_info,
+                                               NULL,
                                                CHECK_NULL);
 
     if (log_is_enabled(Debug, class, resolve)) {
@@ -974,6 +975,7 @@ static jclass jvm_lookup_define_class(jclass lookup, const char *name,
     ik = SystemDictionary::resolve_from_stream(&st, class_name,
                                                class_loader,
                                                cl_info,
+                                               NULL,
                                                CHECK_NULL);
 
     // The hidden class loader data has been artificially been kept alive to
diff --git a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
index 1da6661dd3e..efaf11e1666 100644
--- a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
@@ -24,11 +24,14 @@
 
 #include "precompiled.hpp"
 #include "aot/aotLoader.hpp"
+#include "classfile/classFileParser.hpp"
 #include "classfile/classFileStream.hpp"
 #include "classfile/metadataOnStackMark.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/verifier.hpp"
 #include "classfile/dictionary.hpp"
+#include "classfile/classLoaderDataGraph.hpp"
+#include "interpreter/linkResolver.hpp"
 #include "interpreter/oopMapCache.hpp"
 #include "interpreter/rewriter.hpp"
 #include "logging/logStream.hpp"
@@ -37,17 +40,22 @@
 #include "memory/resourceArea.hpp"
 #include "memory/iterator.inline.hpp"
 #include "oops/fieldStreams.hpp"
+#include "oops/fieldStreams.inline.hpp"
 #include "oops/klassVtable.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/constantPool.inline.hpp"
+#include "oops/metadata.hpp"
+#include "oops/methodData.hpp"
 #include "prims/jvmtiImpl.hpp"
 #include "prims/jvmtiClassFileReconstituter.hpp"
 #include "prims/jvmtiEnhancedRedefineClasses.hpp"
 #include "prims/methodComparator.hpp"
 #include "prims/resolvedMethodTable.hpp"
+#include "prims/methodHandles.hpp"
 #include "runtime/deoptimization.hpp"
 #include "runtime/jniHandles.inline.hpp"
 #include "runtime/relocator.hpp"
+#include "runtime/fieldDescriptor.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "utilities/bitMap.inline.hpp"
 #include "prims/jvmtiThreadState.inline.hpp"
@@ -55,6 +63,8 @@
 #include "oops/constantPool.inline.hpp"
 #include "gc/g1/g1CollectedHeap.hpp"
 #include "gc/shared/dcevmSharedGC.hpp"
+#include "gc/shared/scavengableNMethods.hpp"
+#include "ci/ciObjectFactory.hpp"
 
 Array<Method*>* VM_EnhancedRedefineClasses::_old_methods = NULL;
 Array<Method*>* VM_EnhancedRedefineClasses::_new_methods = NULL;
@@ -66,6 +76,7 @@ int         VM_EnhancedRedefineClasses::_matching_methods_length = 0;
 int         VM_EnhancedRedefineClasses::_deleted_methods_length  = 0;
 int         VM_EnhancedRedefineClasses::_added_methods_length    = 0;
 Klass*      VM_EnhancedRedefineClasses::_the_class_oop = NULL;
+u8        VM_EnhancedRedefineClasses::_id_counter = 0;
 
 //
 // Create new instance of enhanced class redefiner.
@@ -88,6 +99,7 @@ VM_EnhancedRedefineClasses::VM_EnhancedRedefineClasses(jint class_count, const j
   _class_load_kind = class_load_kind;
   _res = JVMTI_ERROR_NONE;
   _any_class_has_resolved_methods = false;
+  _id = next_id();
 }
 
 static inline InstanceKlass* get_ik(jclass def) {
@@ -211,9 +223,7 @@ class FieldCopier : public FieldClosure {
 
 // TODO: review...
 void VM_EnhancedRedefineClasses::mark_as_scavengable(nmethod* nm) {
-  if (!nm->on_scavenge_root_list()) {
-    CodeCache::add_scavenge_root_nmethod(nm);
-  }
+  ScavengableNMethods::register_nmethod(nm);
 }
 
 void VM_EnhancedRedefineClasses::unregister_nmethod_g1(nmethod* nm) {
@@ -414,7 +424,7 @@ public:
       _tmp_obj_size = size;
       _tmp_obj = (oop)resource_allocate_bytes(size * HeapWordSize);
     }
-    Copy::aligned_disjoint_words((HeapWord*)o, (HeapWord*)_tmp_obj, size);
+    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(o), cast_from_oop<HeapWord*>(_tmp_obj), size);
   }
 
   virtual void do_object(oop obj) {
@@ -498,16 +508,13 @@ void VM_EnhancedRedefineClasses::doit() {
 
   // Deoptimize all compiled code that depends on this class (do only once, because it clears whole cache)
   // if (_max_redefinition_flags > Klass::ModifyClass) {
-    flush_dependent_code(NULL, thread);
+    flush_dependent_code(thread);
   // }
 
     // Adjust constantpool caches for all classes that reference methods of the evolved class.
     ClearCpoolCacheAndUnpatch clear_cpool_cache(thread);
     ClassLoaderDataGraph::classes_do(&clear_cpool_cache);
 
-
-    // SystemDictionary::methods_do(fix_invoke_method);
-
   // JSR-292 support
   if (_any_class_has_resolved_methods) {
     bool trace_name_printed = false;
@@ -564,8 +571,8 @@ void VM_EnhancedRedefineClasses::doit() {
     InstanceKlass* old = InstanceKlass::cast(cur->old_version());
 
     // Swap marks to have same hashcodes
-    markOop cur_mark = cur->prototype_header();
-    markOop old_mark = old->prototype_header();
+    markWord cur_mark = cur->prototype_header();
+    markWord old_mark = old->prototype_header();
     cur->set_prototype_header(old_mark);
     old->set_prototype_header(cur_mark);
 
@@ -579,14 +586,14 @@ void VM_EnhancedRedefineClasses::doit() {
       // Revert pool holder for old version of klass (it was updated by one of ours closure!)
     old->constants()->set_pool_holder(old);
 
-    Klass* array_klasses = old->array_klasses();
+    ObjArrayKlass* array_klasses = old->array_klasses();
     if (array_klasses != NULL) {
       assert(cur->array_klasses() == NULL, "just checking");
 
       // Transfer the array classes, otherwise we might get cast exceptions when casting array types.
       // Also, set array klasses element klass.
       cur->set_array_klasses(array_klasses);
-      ObjArrayKlass::cast(array_klasses)->set_element_klass(cur);
+      array_klasses->set_element_klass(cur);
       java_lang_Class::release_set_array_klass(cur->java_mirror(), array_klasses);
       java_lang_Class::set_component_mirror(array_klasses->java_mirror(), cur->java_mirror());
     }
@@ -640,12 +647,7 @@ void VM_EnhancedRedefineClasses::doit() {
   //MethodDataCleaner clean_weak_method_links;
   //ClassLoaderDataGraph::classes_do(&clean_weak_method_links);
 
-  // Disable any dependent concurrent compilations
-  SystemDictionary::notice_modification();
-
-  // Set flag indicating that some invariants are no longer true.
-  // See jvmtiExport.hpp for detailed explanation.
-  JvmtiExport::set_has_redefined_a_class();
+  JvmtiExport::increment_redefinition_count();
 
 #ifdef PRODUCT
   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
@@ -718,7 +720,7 @@ bool VM_EnhancedRedefineClasses::is_modifiable_class(oop klass_mirror) {
   }
 
   // Cannot redefine or retransform an anonymous class.
-  if (InstanceKlass::cast(k)->is_anonymous()) {
+  if (InstanceKlass::cast(k)->is_unsafe_anonymous()) {
     return false;
   }
   return true;
@@ -804,22 +806,30 @@ jvmtiError VM_EnhancedRedefineClasses::load_new_class_versions(TRAPS) {
 
     InstanceKlass* k;
 
-    if (InstanceKlass::cast(the_class)->is_anonymous()) {
-      const InstanceKlass* host_class = the_class->host_klass();
+    if (InstanceKlass::cast(the_class)->is_unsafe_anonymous()) {
+      const InstanceKlass* host_class = the_class->unsafe_anonymous_host();
 
       // Make sure it's the real host class, not another anonymous class.
-      while (host_class != NULL && host_class->is_anonymous()) {
-        host_class = host_class->host_klass();
+      while (host_class != NULL && host_class->is_unsafe_anonymous()) {
+        host_class = host_class->unsafe_anonymous_host();
       }
 
+      ClassLoadInfo cl_info(protection_domain,
+                            host_class,
+                            NULL,     // dynamic_nest_host
+                            NULL,     // cp_patches
+                            Handle(), // classData
+                            false,    // is_hidden
+                            false,    // is_strong_hidden
+                            true);    // FIXME: check if correct. can_access_vm_annotations
+
       k = SystemDictionary::parse_stream(the_class_sym,
                                          the_class_loader,
-                                         protection_domain,
                                          &st,
-                                         host_class,
+                                         cl_info,
                                          the_class,
-                                         NULL,
                                          THREAD);
+
       k->class_loader_data()->exchange_holders(the_class->class_loader_data());
       the_class->class_loader_data()->inc_keep_alive();
     } else {
@@ -966,7 +976,7 @@ int VM_EnhancedRedefineClasses::calculate_redefinition_flags(InstanceKlass* new_
   // Check interfaces
 
   // Interfaces removed?
-  Array<Klass*>* old_interfaces = the_class->transitive_interfaces();
+  Array<InstanceKlass*>* old_interfaces = the_class->transitive_interfaces();
   for (i = 0; i < old_interfaces->length(); i++) {
     InstanceKlass* old_interface = InstanceKlass::cast(old_interfaces->at(i));
     if (!new_class->implements_interface_any_version(old_interface)) {
@@ -976,7 +986,7 @@ int VM_EnhancedRedefineClasses::calculate_redefinition_flags(InstanceKlass* new_
   }
 
   // Interfaces added?
-  Array<Klass*>* new_interfaces = new_class->transitive_interfaces();
+  Array<InstanceKlass*>* new_interfaces = new_class->transitive_interfaces();
   for (i = 0; i<new_interfaces->length(); i++) {
     if (!the_class->implements_interface_any_version(new_interfaces->at(i))) {
       result = result | Klass::ModifyClass;
@@ -1389,8 +1399,8 @@ void VM_EnhancedRedefineClasses::rollback() {
 // Rewrite faster byte-codes back to their slower equivalent. Undoes rewriting happening in templateTable_xxx.cpp
 // The reason is that once we zero cpool caches, we need to re-resolve all entries again. Faster bytecodes do not
 // do that, they assume that cache entry is resolved already.
-void VM_EnhancedRedefineClasses::unpatch_bytecode(Method* method) {
-  RawBytecodeStream bcs(method);
+void VM_EnhancedRedefineClasses::unpatch_bytecode(Method* method, TRAPS) {
+  RawBytecodeStream bcs(methodHandle(THREAD, method));
   Bytecodes::Code code;
   Bytecodes::Code java_code;
   while (!bcs.is_last_bytecode()) {
@@ -1454,11 +1464,11 @@ void VM_EnhancedRedefineClasses::ClearCpoolCacheAndUnpatch::do_klass(Klass* k) {
   HandleMark hm(_thread);
   InstanceKlass *ik = InstanceKlass::cast(k);
 
-  constantPoolHandle other_cp = constantPoolHandle(ik->constants());
+  constantPoolHandle other_cp = constantPoolHandle(_thread, ik->constants());
 
   // Update host klass of anonymous classes (for example, produced by lambdas) to newest version.
-  if (ik->is_anonymous() && ik->host_klass()->new_version() != NULL) {
-    ik->set_host_klass(InstanceKlass::cast(ik->host_klass()->newest_version()));
+  if (ik->is_unsafe_anonymous() && ik->unsafe_anonymous_host()->new_version() != NULL) {
+    ik->set_unsafe_anonymous_host(InstanceKlass::cast(ik->unsafe_anonymous_host()->newest_version()));
   }
 
   // Update implementor if there is only one, in this case implementor() can reference old class
@@ -1492,7 +1502,18 @@ void VM_EnhancedRedefineClasses::ClearCpoolCacheAndUnpatch::do_klass(Klass* k) {
 
   // If bytecode rewriting is enabled, we also need to unpatch bytecode to force resolution of zeroed entries
   if (RewriteBytecodes) {
-    ik->methods_do(unpatch_bytecode);
+    ik->methods_do(unpatch_bytecode, _thread);
+  }
+}
+
+u8 VM_EnhancedRedefineClasses::next_id() {
+  while (true) {
+    u8 id = _id_counter;
+    u8 next_id = id + 1;
+    u8 result = Atomic::cmpxchg(&_id_counter, id, next_id);
+    if (result == id) {
+      return next_id;
+    }
   }
 }
 
@@ -1512,31 +1533,8 @@ void VM_EnhancedRedefineClasses::MethodDataCleaner::do_klass(Klass* k) {
   }
 }
 
-void VM_EnhancedRedefineClasses::fix_invoke_method(Method* method) {
-
-  constantPoolHandle other_cp = constantPoolHandle(method->constants());
-
-  for (int i = 0; i < other_cp->length(); i++) {
-    if (other_cp->tag_at(i).is_klass()) {
-      Klass* klass = other_cp->resolved_klass_at(i);
-      if (klass->new_version() != NULL) {
-        // Constant pool entry points to redefined class -- update to the new version
-        other_cp->klass_at_put(i, klass->newest_version());
-      }
-      assert(other_cp->resolved_klass_at(i)->new_version() == NULL, "Must be new klass!");
-    }
-  }
 
-  ConstantPoolCache* cp_cache = other_cp->cache();
-  if (cp_cache != NULL) {
-    cp_cache->clear_entries();
-  }
-
-}
-
-
-
-void VM_EnhancedRedefineClasses::update_jmethod_ids() {
+void VM_EnhancedRedefineClasses::update_jmethod_ids(TRAPS) {
   for (int j = 0; j < _matching_methods_length; ++j) {
     Method* old_method = _matching_old_methods[j];
     jmethodID jmid = old_method->find_jmethod_id_or_null();
@@ -1547,10 +1545,10 @@ void VM_EnhancedRedefineClasses::update_jmethod_ids() {
 
     if (jmid != NULL) {
       // There is a jmethodID, change it to point to the new method
-      methodHandle new_method_h(_matching_new_methods[j]);
+      methodHandle new_method_h(THREAD, _matching_new_methods[j]);
 
       if (old_method->new_version() == NULL) {
-        methodHandle old_method_h(_matching_old_methods[j]);
+        methodHandle old_method_h(THREAD, _matching_old_methods[j]);
         jmethodID new_jmethod_id = Method::make_jmethod_id(old_method_h->method_holder()->class_loader_data(), old_method_h());
         bool result = InstanceKlass::cast(old_method_h->method_holder())->update_jmethod_id(old_method_h(), new_jmethod_id);
       } else {
@@ -1739,6 +1737,18 @@ void VM_EnhancedRedefineClasses::transfer_old_native_function_registrations(Inst
   transfer.transfer_registrations(_matching_old_methods, _matching_methods_length);
 }
 
+// First step is to walk the code cache for each class redefined and mark
+// dependent methods.  Wait until all classes are processed to deoptimize everything.
+void VM_EnhancedRedefineClasses::mark_dependent_code(InstanceKlass* ik) {
+  assert_locked_or_safepoint(Compile_lock);
+
+  // All dependencies have been recorded from startup or this is a second or
+  // subsequent use of RedefineClasses
+  if (0 && JvmtiExport::all_dependencies_are_recorded()) {
+    CodeCache::mark_for_evol_deoptimization(ik);
+  }
+}
+
 // DCEVM - it always deoptimizes everything! (because it is very difficult to find only correct dependencies)
 // Deoptimize all compiled code that depends on this class.
 //
@@ -1755,33 +1765,21 @@ void VM_EnhancedRedefineClasses::transfer_old_native_function_registrations(Inst
 // subsequent calls to RedefineClasses need only throw away code
 // that depends on the class.
 //
-void VM_EnhancedRedefineClasses::flush_dependent_code(InstanceKlass* k_h, TRAPS) {
+void VM_EnhancedRedefineClasses::flush_dependent_code(TRAPS) {
   assert_locked_or_safepoint(Compile_lock);
 
   // All dependencies have been recorded from startup or this is a second or
   // subsequent use of RedefineClasses
   // FIXME: for now, deoptimize all!
-  if (0 && k_h != NULL && JvmtiExport::all_dependencies_are_recorded()) {
-    CodeCache::flush_evol_dependents_on(k_h);
-    Klass* superCl = k_h->super();
-    // Deoptimize super classes since redefined class can has a new method override
-    while (superCl != NULL && !superCl->is_redefining()) {
-      CodeCache::flush_evol_dependents_on(InstanceKlass::cast(superCl));
-      superCl = superCl->super();
+  if (0 && JvmtiExport::all_dependencies_are_recorded()) {
+    int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
+    log_debug(redefine, class, nmethod)("Marked %d dependent nmethods for deopt", deopt);
+    if (deopt != 0) {
+      CodeCache::flush_evol_dependents();
     }
   } else {
-    CodeCache::mark_all_nmethods_for_deoptimization();
-
-    ResourceMark rm(THREAD);
-    DeoptimizationMarker dm;
-
-    // Deoptimize all activations depending on marked nmethods
-    Deoptimization::deoptimize_dependents();
-
-    // Make the dependent methods not entrant
-    CodeCache::make_marked_nmethods_not_entrant();
-
-    // From now on we know that the dependency information is complete
+    CodeCache::mark_all_nmethods_for_evol_deoptimization();
+    CodeCache::flush_evol_dependents();
     JvmtiExport::set_all_dependencies_are_recorded(true);
   }
 }
@@ -1874,11 +1872,7 @@ void VM_EnhancedRedefineClasses::redefine_single_class(InstanceKlass* new_class_
   JvmtiBreakpoints& jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
 
-  // DCEVM Deoptimization is always for whole java world, call only once after all classes are redefined
-  // Deoptimize all compiled code that depends on this class
-//  if (_max_redefinition_flags <= Klass::ModifyClass) {
-//    flush_dependent_code(the_class, THREAD);
-//  }
+  mark_dependent_code(the_class);
 
   _old_methods = the_class->methods();
   _new_methods = new_class->methods();
@@ -1887,7 +1881,7 @@ void VM_EnhancedRedefineClasses::redefine_single_class(InstanceKlass* new_class_
 
   // track number of methods that are EMCP for add_previous_version() call below
   check_methods_and_mark_as_obsolete();
-  update_jmethod_ids();
+  update_jmethod_ids(THREAD);
 
   _any_class_has_resolved_methods = the_class->has_resolved_methods() || _any_class_has_resolved_methods;
 
@@ -2119,12 +2113,12 @@ jvmtiError VM_EnhancedRedefineClasses::do_topological_class_sorting(TRAPS) {
 
     Handle protection_domain(THREAD, klass->protection_domain());
 
+    ClassLoadInfo cl_info(protection_domain);
+
     ClassFileParser parser(&st,
                            klass->name(),
                            klass->class_loader_data(),
-                           protection_domain,
-                           NULL, // host_klass
-                           NULL, // cp_patches
+                           &cl_info,
                            ClassFileParser::INTERNAL, // publicity level
                            true,
                            THREAD);
@@ -2134,7 +2128,7 @@ jvmtiError VM_EnhancedRedefineClasses::do_topological_class_sorting(TRAPS) {
       links.append(KlassPair(super_klass, klass));
     }
 
-    Array<Klass*>* local_interfaces = parser.local_interfaces();
+    Array<InstanceKlass*>* local_interfaces = parser.local_interfaces();
     for (int j = 0; j < local_interfaces->length(); j++) {
       Klass* iface = local_interfaces->at(j);
       if (iface != NULL && _affected_klasses->contains(iface)) {
@@ -2157,7 +2151,7 @@ jvmtiError VM_EnhancedRedefineClasses::do_topological_class_sorting(TRAPS) {
         links.append(KlassPair(super_klass, klass));
       }
 
-      Array<Klass*>* local_interfaces = klass->local_interfaces();
+      Array<InstanceKlass*>* local_interfaces = klass->local_interfaces();
       for (int j = 0; j < local_interfaces->length(); j++) {
         Klass* interfaceKlass = local_interfaces->at(j);
         if (_affected_klasses->contains(interfaceKlass)) {
diff --git a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.hpp b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.hpp
index 4c0412d343d..bd5e7d153be 100644
--- a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.hpp
+++ b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.hpp
@@ -32,7 +32,7 @@
 #include "memory/resourceArea.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/objArrayOop.hpp"
-#include "gc/shared/vmGCOperations.hpp"
+#include "gc/shared/gcVMOperations.hpp"
 #include "../../../java.base/unix/native/include/jni_md.h"
 
 //
@@ -59,6 +59,7 @@ class VM_EnhancedRedefineClasses: public VM_GC_Operation {
   static int             _deleted_methods_length;
   static int             _added_methods_length;
   static Klass*          _the_class_oop;
+  static u8              _id_counter;
 
   // The instance fields are used to pass information from
   // doit_prologue() to doit() and doit_epilogue().
@@ -91,6 +92,9 @@ class VM_EnhancedRedefineClasses: public VM_GC_Operation {
   elapsedTimer  _timer_heap_iterate;
   elapsedTimer  _timer_heap_full_gc;
 
+  // Redefinition id used by JFR
+  u8 _id;
+
   // These routines are roughly in call order unless otherwise noted.
 
   // Load and link new classes (either redefined or affected by redefinition - subclass, ...)
@@ -118,15 +122,14 @@ class VM_EnhancedRedefineClasses: public VM_GC_Operation {
   static void mark_as_scavengable(nmethod* nm);
   static void unregister_nmethod_g1(nmethod* nm);
   static void register_nmethod_g1(nmethod* nm);
-  static void unpatch_bytecode(Method* method);
-  static void fix_invoke_method(Method* method);
+  static void unpatch_bytecode(Method* method, TRAPS);
 
   // Figure out which new methods match old methods in name and signature,
   // which methods have been added, and which are no longer present
   void compute_added_deleted_matching_methods();
 
   // Change jmethodIDs to point to the new methods
-  void update_jmethod_ids();
+  void update_jmethod_ids(TRAPS);
 
   // marking methods as old and/or obsolete
   void check_methods_and_mark_as_obsolete();
@@ -139,7 +142,11 @@ class VM_EnhancedRedefineClasses: public VM_GC_Operation {
   // and in all direct and indirect subclasses.
   void increment_class_counter(InstanceKlass *ik, TRAPS);
 
-  void flush_dependent_code(InstanceKlass* k_h, TRAPS);
+  void mark_dependent_code(InstanceKlass* ik);
+
+  void flush_dependent_code(TRAPS);
+
+  u8 next_id();
 
   static void check_class(InstanceKlass* k_oop, TRAPS);
 
@@ -181,6 +188,7 @@ class VM_EnhancedRedefineClasses: public VM_GC_Operation {
 
   bool allow_nested_vm_operations() const        { return true; }
   jvmtiError check_error()                       { return _res; }
+  u8 id()                                        { return _id; }
 
   // Modifiable test must be shared between IsModifiableClass query
   // and redefine implementation
diff --git a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
index 6d1692949cb..8970d7991b7 100644
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -454,20 +454,23 @@ JvmtiEnv::RetransformClasses(jint class_count, const jclass* classes) {
 
   EventRetransformClasses event;
   jvmtiError error;
+  u8 op_id;
 
   if (AllowEnhancedClassRedefinition) {
     MutexLocker sd_mutex(EnhancedRedefineClasses_lock);
     VM_EnhancedRedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_retransform);
     VMThread::execute(&op);
+    op_id = op.id();
     error = (op.check_error());
   } else {
     VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_retransform);
     VMThread::execute(&op);
+    op_id = op.id();
     error = op.check_error();
   }
   if (error == JVMTI_ERROR_NONE) {
     event.set_classCount(class_count);
-    event.set_redefinitionId(op.id());
+    event.set_redefinitionId(op_id);
     event.commit();
   }
   return error;
@@ -482,19 +485,23 @@ JvmtiEnv::RedefineClasses(jint class_count, const jvmtiClassDefinition* class_de
   EventRedefineClasses event;
   jvmtiError error;
 
+  u8 op_id;
+
   if (AllowEnhancedClassRedefinition) {
     MutexLocker sd_mutex(EnhancedRedefineClasses_lock);
     VM_EnhancedRedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);
     VMThread::execute(&op);
+    op_id = op.id();
     error = (op.check_error());
   } else {
     VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);
     VMThread::execute(&op);
+    op_id = op.id();
     error = op.check_error();
   }
   if (error == JVMTI_ERROR_NONE) {
     event.set_classCount(class_count);
-    event.set_redefinitionId(op.id());
+    event.set_redefinitionId(op_id);
     event.commit();
   }
   return error;
diff --git a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
index 99479bb8b7a..87b3b5f47ce 100644
--- a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
@@ -1390,6 +1390,7 @@ jvmtiError VM_RedefineClasses::load_new_class_versions() {
                                                       the_class->name(),
                                                       the_class->class_loader_data(),
                                                       cl_info,
+                                                      NULL,
                                                       THREAD);
 
     // Clear class_being_redefined just to be sure.
diff --git a/src/hotspot/share/prims/methodHandles.hpp b/src/hotspot/share/prims/methodHandles.hpp
index ad8c935c64b..7d6dc5e4281 100644
--- a/src/hotspot/share/prims/methodHandles.hpp
+++ b/src/hotspot/share/prims/methodHandles.hpp
@@ -183,6 +183,9 @@ public:
     assert(ref_kind_is_valid(ref_kind), "");
     return (ref_kind & 1) != 0;
   }
+  static bool ref_kind_is_static(int ref_kind) {
+    return !ref_kind_has_receiver(ref_kind) && (ref_kind != JVM_REF_newInvokeSpecial);
+  }
 
   static int ref_kind_to_flags(int ref_kind);
 
diff --git a/src/hotspot/share/prims/resolvedMethodTable.cpp b/src/hotspot/share/prims/resolvedMethodTable.cpp
index b8d039adff6..3c29eda4da0 100644
--- a/src/hotspot/share/prims/resolvedMethodTable.cpp
+++ b/src/hotspot/share/prims/resolvedMethodTable.cpp
@@ -370,6 +370,67 @@ public:
   }
 };
 
+class AdjustMethodEntriesDcevm : public StackObj {
+  bool* _trace_name_printed;
+  GrowableArray<oop>* _oops_to_add;
+public:
+  AdjustMethodEntriesDcevm(GrowableArray<oop>* oops_to_add, bool* trace_name_printed) : _trace_name_printed(trace_name_printed), _oops_to_add(oops_to_add) {};
+  bool operator()(WeakHandle<vm_resolved_method_table_data>* entry) {
+    oop mem_name = entry->peek();
+    if (mem_name == NULL) {
+      // Removed
+      return true;
+    }
+
+    Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);
+
+    if (old_method->is_old()) {
+
+      InstanceKlass* newer_klass = InstanceKlass::cast(old_method->method_holder()->new_version());
+      Method* newer_method;
+
+      // Method* new_method;
+      if (old_method->is_deleted()) {
+        newer_method = Universe::throw_no_such_method_error();
+      } else {
+        newer_method = newer_klass->method_with_idnum(old_method->orig_method_idnum());
+
+        log_debug(redefine, class, update)("Adjusting method: '%s' of new class %s", newer_method->name_and_sig_as_C_string(), newer_klass->name()->as_C_string());
+
+        assert(newer_klass == newer_method->method_holder(), "call after swapping redefined guts");
+        assert(newer_method != NULL, "method_with_idnum() should not be NULL");
+        assert(old_method != newer_method, "sanity check");
+
+        Thread* thread = Thread::current();
+        ResolvedMethodTableLookup lookup(thread, method_hash(newer_method), newer_method);
+        ResolvedMethodGet rmg(thread, newer_method);
+
+        if (_local_table->get(thread, lookup, rmg)) {
+          // old method was already adjusted if new method exists in _the_table
+            return true;
+        }
+      }
+
+      java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, newer_method);
+      java_lang_invoke_ResolvedMethodName::set_vmholder(mem_name, newer_method->method_holder()->java_mirror());
+
+      newer_klass->set_has_resolved_methods();
+      _oops_to_add->append(mem_name);
+
+      ResourceMark rm;
+      if (!(*_trace_name_printed)) {
+        log_debug(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
+         *_trace_name_printed = true;
+      }
+      log_debug(redefine, class, update, constantpool)
+        ("ResolvedMethod method update: %s(%s)",
+         newer_method->name()->as_C_string(), newer_method->signature()->as_C_string());
+    }
+
+    return true;
+  }
+};
+
 // It is called at safepoint only for RedefineClasses
 void ResolvedMethodTable::adjust_method_entries(bool * trace_name_printed) {
   assert(SafepointSynchronize::is_at_safepoint(), "only called at safepoint");
@@ -377,73 +438,41 @@ void ResolvedMethodTable::adjust_method_entries(bool * trace_name_printed) {
   AdjustMethodEntries adjust(trace_name_printed);
   _local_table->do_safepoint_scan(adjust);
 }
-#endif // INCLUDE_JVMTI
 
-// (DCEVM) It is called at safepoint only for RedefineClasses
+// It is called at safepoint only for RedefineClasses
 void ResolvedMethodTable::adjust_method_entries_dcevm(bool * trace_name_printed) {
   assert(SafepointSynchronize::is_at_safepoint(), "only called at safepoint");
   // For each entry in RMT, change to new method
-  GrowableArray<oop>* oops_to_add = new GrowableArray<oop>();
-
-  for (int i = 0; i < _the_table->table_size(); ++i) {
-    for (ResolvedMethodEntry* entry = _the_table->bucket(i);
-         entry != NULL;
-         entry = entry->next()) {
-
-      oop mem_name = entry->object_no_keepalive();
-      // except ones removed
-      if (mem_name == NULL) {
-        continue;
-      }
-      Method* old_method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);
-
-      if (old_method->is_old()) {
-
-        InstanceKlass* newer_klass = InstanceKlass::cast(old_method->method_holder()->new_version());
-        Method* newer_method;
-
-        // Method* new_method;
-        if (old_method->is_deleted()) {
-          newer_method = Universe::throw_no_such_method_error();
-        } else {
-          newer_method = newer_klass->method_with_idnum(old_method->orig_method_idnum());
-
-          log_debug(redefine, class, update)("Adjusting method: '%s' of new class %s", newer_method->name_and_sig_as_C_string(), newer_klass->name()->as_C_string());
-
-          assert(newer_klass == newer_method->method_holder(), "call after swapping redefined guts");
-          assert(newer_method != NULL, "method_with_idnum() should not be NULL");
-          assert(old_method != newer_method, "sanity check");
-
-          if (_the_table->lookup(newer_method) != NULL) {
-            // old method was already adjusted if new method exists in _the_table
-              continue;
-          }
-        }
+  GrowableArray<oop> oops_to_add(0);
+  AdjustMethodEntriesDcevm adjust(&oops_to_add, trace_name_printed);
+  _local_table->do_safepoint_scan(adjust);
+  Thread* thread = Thread::current();
+  for (int i = 0; i < oops_to_add.length(); i++) {
+    oop mem_name = oops_to_add.at(i);
+    Method* method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);
 
-        java_lang_invoke_ResolvedMethodName::set_vmtarget(mem_name, newer_method);
-        java_lang_invoke_ResolvedMethodName::set_vmholder_offset(mem_name, newer_method);
+    // The hash table takes ownership of the WeakHandle, even if it's not inserted.
 
-        newer_klass->set_has_resolved_methods();
-        oops_to_add->append(mem_name);
+    ResolvedMethodTableLookup lookup(thread, method_hash(method), method);
+    ResolvedMethodGet rmg(thread, method);
 
-        ResourceMark rm;
-        if (!(*trace_name_printed)) {
-          log_debug(redefine, class, update)("adjust: name=%s", old_method->method_holder()->external_name());
-           *trace_name_printed = true;
-        }
-        log_debug(redefine, class, update, constantpool)
-          ("ResolvedMethod method update: %s(%s)",
-           newer_method->name()->as_C_string(), newer_method->signature()->as_C_string());
+    while (true) {
+      if (_local_table->get(thread, lookup, rmg)) {
+        break;
+      }
+      WeakHandle<vm_resolved_method_table_data> wh = WeakHandle<vm_resolved_method_table_data>::create(Handle(thread, mem_name));
+      // The hash table takes ownership of the WeakHandle, even if it's not inserted.
+      if (_local_table->insert(thread, lookup, wh)) {
+        log_insert(method);
+        wh.resolve();
+        break;
       }
-    }
-    for (int i = 0; i < oops_to_add->length(); i++) {
-        oop mem_name = oops_to_add->at(i);
-        Method* method = (Method*)java_lang_invoke_ResolvedMethodName::vmtarget(mem_name);
-        _the_table->basic_add(method, Handle(Thread::current(), mem_name));
     }
   }
 }
 
+#endif // INCLUDE_JVMTI
+
 // Verification
 class VerifyResolvedMethod : StackObj {
  public:
diff --git a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
index b7bb88e2a46..567803b70b7 100644
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -1975,13 +1975,15 @@ bool Arguments::check_gc_consistency() {
   // of collectors.
   uint i = 0;
   if (UseSerialGC)                       i++;
-  if (UseConcMarkSweepGC)                i++;
-  if (UseParallelGC || UseParallelOldGC) i++;
+  if (UseParallelGC)                     i++;
   if (UseG1GC)                           i++;
+  if (UseEpsilonGC)                      i++;
+  if (UseZGC)                            i++;
+  if (UseShenandoahGC)                   i++;
   if (AllowEnhancedClassRedefinition) {
     // Must use serial GC. This limitation applies because the instance size changing GC modifications
     // are only built into the mark and compact algorithm.
-    if ((!UseSerialGC && !UseG1GC) && i >= 1) {
+    if (!UseSerialGC && !UseG1GC && i >= 1) {
       jio_fprintf(defaultStream::error_stream(),
                   "Must use the Serial or G1 GC with enhanced class redefinition.\n");
       return false;
diff --git a/src/hotspot/share/runtime/mutexLocker.cpp b/src/hotspot/share/runtime/mutexLocker.cpp
index d6fa631c967..83982382e6f 100644
--- a/src/hotspot/share/runtime/mutexLocker.cpp
+++ b/src/hotspot/share/runtime/mutexLocker.cpp
@@ -283,7 +283,7 @@ void mutex_init() {
   def(InitCompleted_lock           , PaddedMonitor, leaf,        true,  _safepoint_check_never);
   def(VtableStubs_lock             , PaddedMutex  , nonleaf,     true,  _safepoint_check_never);
   def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);
-  def(EnhancedRedefineClasses_lock , PaddedMutex  , nonleaf+7,   false, Monitor::_safepoint_check_always);     // for ensuring that class redefinition is not done in parallel
+  def(EnhancedRedefineClasses_lock , PaddedMutex  , nonleaf+7,   false, _safepoint_check_always);     // for ensuring that class redefinition is not done in parallel
   def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  _safepoint_check_always); // used for JNI critical regions
   def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  _safepoint_check_always);
 
-- 
2.23.0

